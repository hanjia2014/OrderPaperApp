import ts from 'typescript';
import Logger from './logger';
import { isTypescriptDeclaration, hasError } from './utils';
var logger = new Logger({ debug: false });
var TypeChecker = (function () {
    function TypeChecker(host) {
        this._host = host;
    }
    TypeChecker.prototype.getTypeCheckOptions = function (options) {
        var result = ts.clone(options);
        result.inlineSourceMap = false;
        result.sourceMap = false;
        result.declaration = false;
        result.isolatedModules = false;
        result.skipDefaultLibCheck = true;
        return result;
    };
    TypeChecker.prototype.check = function (options) {
        var typeCheckOptions = this.getTypeCheckOptions(options);
        var candidates = this.getCandidates(false);
        if (candidates.some(function (candidate) { return !candidate.file.checked && candidate.checkable && !isTypescriptDeclaration(candidate.name); }))
            return this.getAllDiagnostics(candidates, typeCheckOptions);
        else
            return [];
    };
    TypeChecker.prototype.forceCheck = function (options) {
        var typeCheckOptions = this.getTypeCheckOptions(options);
        var candidates = this.getCandidates(true);
        if (candidates.some(function (candidate) { return !candidate.file.checked; }))
            return this.getAllDiagnostics(candidates, typeCheckOptions);
        else
            return [];
    };
    TypeChecker.prototype.getFileDiagnostics = function (fileName) {
        return this._host.getSourceFile(fileName).diags;
    };
    TypeChecker.prototype.hasErrors = function () {
        return this._host.getAllFiles()
            .some(function (file) { return file.checked && hasError(file.diags); });
    };
    TypeChecker.prototype.getCandidates = function (force) {
        var _this = this;
        var candidates = this._host
            .getAllFiles()
            .map(function (file) { return ({
            name: file.fileName,
            file: file,
            seen: false,
            resolved: !!file.dependencies,
            checkable: force || undefined,
            deps: file.dependencies && file.dependencies.list
        }); });
        if (!force) {
            var candidatesMap_1 = candidates.reduce(function (result, candidate) {
                result[candidate.name] = candidate;
                return result;
            }, {});
            candidates.forEach(function (candidate) { return candidate.checkable = _this.isCheckable(candidate, candidatesMap_1); });
        }
        return candidates;
    };
    TypeChecker.prototype.isCheckable = function (candidate, candidatesMap) {
        var _this = this;
        if (!candidate)
            return false;
        else {
            if (!candidate.seen) {
                candidate.seen = true;
                candidate.checkable = candidate.resolved && candidate.deps.every(function (dep) { return _this.isCheckable(candidatesMap[dep], candidatesMap); });
            }
            return (candidate.checkable !== false);
        }
    };
    TypeChecker.prototype.getAllDiagnostics = function (candidates, typeCheckOptions) {
        var filelist = candidates.map(function (dep) { return dep.name; });
        var program = ts.createProgram(filelist, typeCheckOptions, this._host);
        return candidates.reduce(function (diags, candidate) {
            if (candidate.checkable && !candidate.file.checked) {
                candidate.file.diags = [];
                if (!candidate.file.isLibFile) {
                    candidate.file.diags = program.getSyntacticDiagnostics(candidate.file)
                        .concat(program.getSemanticDiagnostics(candidate.file));
                }
                candidate.file.checked = true;
                return diags.concat(candidate.file.diags);
            }
            else {
                return diags;
            }
        }, program.getGlobalDiagnostics());
    };
    return TypeChecker;
}());
export { TypeChecker };
