import * as tslib_1 from "tslib";
import ts from 'typescript';
import Logger from './logger';
import { createFactory } from './factory';
import { convertErrors, formatErrors } from './format-errors';
import { isTypescript, isTypescriptDeclaration, isJson, stripDoubleExtension, hasError } from './utils';
var logger = new Logger({ debug: false });
var factory = null;
function getFactory() {
    var __global = typeof (self) !== 'undefined' ? self : global;
    __global.tsfactory = __global.tsfactory || createFactory(SystemJS.typescriptOptions, false, _resolve, _fetchJson, _lookup)
        .then(function (output) {
        validateOptions(output.options);
        return output;
    });
    return __global.tsfactory;
}
export function translate(load) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var loader, _a, transpiler, resolver, typeChecker, host, options, result, deps, diags, failOnError;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    loader = this;
                    logger.debug("systemjs translating " + load.address);
                    if (isJson(load.address))
                        return [2 /*return*/, load.source];
                    factory = factory || getFactory();
                    return [4 /*yield*/, factory];
                case 1:
                    _a = _b.sent(), transpiler = _a.transpiler, resolver = _a.resolver, typeChecker = _a.typeChecker, host = _a.host, options = _a.options;
                    host.addFile(load.address, load.source, options.target);
                    if (isTypescriptDeclaration(load.address)) {
                        if (loader.builder && (options.module == ts.ModuleKind.ES2015)) {
                            load.source = null;
                            load.metadata.format = 'esm';
                        }
                        else {
                            load.source = '';
                            load.metadata.format = 'cjs';
                        }
                    }
                    else {
                        result = transpiler.transpile(load.address, options);
                        formatErrors(result.diags, logger);
                        if (result.failure)
                            throw new Error('TypeScript transpilation failed');
                        load.source = result.js;
                        if (result.sourceMap)
                            load.metadata.sourceMap = JSON.parse(result.sourceMap);
                        if (!options.autoDetectModule) {
                            if (options.module === ts.ModuleKind.System)
                                load.metadata.format = 'register';
                            else if (options.module === ts.ModuleKind.ES2015)
                                load.metadata.format = 'esm';
                            else if (options.module === ts.ModuleKind.CommonJS)
                                load.metadata.format = 'cjs';
                        }
                    }
                    if (!(options.typeCheck && isTypescript(load.address))) return [3 /*break*/, 3];
                    return [4 /*yield*/, resolver.resolve(load.address, options)];
                case 2:
                    deps = _b.sent();
                    load.metadata.deps = deps.list
                        .filter(function (d) { return isTypescript(d); })
                        .filter(function (d) { return d !== load.address; })
                        .map(function (d) { return isTypescriptDeclaration(d) ? d + '!' + __moduleName : d; });
                    diags = typeChecker.check(options);
                    formatErrors(diags, logger);
                    failOnError = !loader.builder && (options.typeCheck === "strict");
                    if (failOnError && hasError(diags))
                        throw new Error("Typescript compilation failed");
                    _b.label = 3;
                case 3: return [2 /*return*/, load.source];
            }
        });
    });
}
export function instantiate(load, origInstantiate) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            if (isJson(load.address)) {
                return [2 /*return*/, JSON.parse(load.source)];
            }
            else {
                return [2 /*return*/, origInstantiate(load)];
            }
            return [2 /*return*/];
        });
    });
}
export function bundle(loads, compileOpts, outputOpts) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _a, typeChecker, host, options, diags;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!factory)
                        return [2 /*return*/, []];
                    return [4 /*yield*/, factory];
                case 1:
                    _a = _b.sent(), typeChecker = _a.typeChecker, host = _a.host, options = _a.options;
                    if (options.typeCheck) {
                        diags = typeChecker.forceCheck(options);
                        formatErrors(diags, logger);
                        loads.forEach(function (load) {
                            var diags = typeChecker.getFileDiagnostics(load.address);
                            var errors = convertErrors(diags);
                            load.metadata.tserrors = errors;
                        });
                        if ((options.typeCheck === "strict") && typeChecker.hasErrors())
                            throw new Error("Typescript compilation failed");
                    }
                    return [2 /*return*/, []];
            }
        });
    });
}
function validateOptions(options) {
    if ((options.module != ts.ModuleKind.System) && (options.module != ts.ModuleKind.ES2015)) {
        logger.warn("transpiling to " + ts.ModuleKind[options.module] + ", consider setting module: \"system\" in typescriptOptions to transpile directly to System.register format");
    }
}
function _resolve(dep, parent) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var normalized;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!parent)
                        parent = __moduleName;
                    return [4 /*yield*/, SystemJS.normalize(dep, parent)];
                case 1:
                    normalized = _a.sent();
                    normalized = normalized.split('!')[0];
                    normalized = stripDoubleExtension(normalized);
                    logger.debug("resolved " + normalized + " (" + parent + " -> " + dep + ")");
                    return [2 /*return*/, ts.normalizePath(normalized)];
            }
        });
    });
}
function _fetchJson(address) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var json;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, SystemJS.import(address + '!' + __moduleName)];
                case 1:
                    json = _a.sent();
                    logger.debug("fetched " + address);
                    return [2 /*return*/, json];
            }
        });
    });
}
function _lookup(address) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var metadata;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    metadata = {};
                    return [4 /*yield*/, SystemJS.locate({ name: address, address: address, metadata: metadata })];
                case 1:
                    _a.sent();
                    logger.debug("located " + address);
                    return [2 /*return*/, metadata];
            }
        });
    });
}
