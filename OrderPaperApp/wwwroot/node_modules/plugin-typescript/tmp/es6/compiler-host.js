import ts from 'typescript';
import Logger from './logger';
import { isTypescriptDeclaration, getExtension } from './utils';
var logger = new Logger({ debug: false });
var CompilerHost = (function () {
    function CompilerHost() {
        this._reportedFiles = [];
        this._files = {};
    }
    CompilerHost.prototype.getDefaultLibFileName = function (options) {
        return this.getDefaultLibFilePaths(options)[0];
    };
    CompilerHost.prototype.getDefaultLibFilePaths = function (options) {
        return options.lib.map(function (libName) { return "typescript/lib/lib." + libName + ".d.ts"; });
    };
    CompilerHost.prototype.useCaseSensitiveFileNames = function () {
        return false;
    };
    CompilerHost.prototype.getCanonicalFileName = function (fileName) {
        return ts.normalizePath(fileName);
    };
    CompilerHost.prototype.getCurrentDirectory = function () {
        return "";
    };
    CompilerHost.prototype.getNewLine = function () {
        return "\n";
    };
    CompilerHost.prototype.readFile = function (fileName) {
        throw new Error("Not implemented");
    };
    CompilerHost.prototype.writeFile = function (name, text, writeByteOrderMark) {
        throw new Error("Not implemented");
    };
    CompilerHost.prototype.getSourceFile = function (fileName) {
        fileName = this.getCanonicalFileName(fileName);
        return this._files[fileName];
    };
    CompilerHost.prototype.getAllFiles = function () {
        var _this = this;
        return Object.keys(this._files).map(function (key) { return _this._files[key]; });
    };
    CompilerHost.prototype.fileExists = function (fileName) {
        return !!this.getSourceFile(fileName);
    };
    CompilerHost.prototype.getDirectories = function () {
        throw new Error("Not implemented");
    };
    CompilerHost.prototype.addFile = function (fileName, text, target) {
        fileName = this.getCanonicalFileName(fileName);
        var file = this._files[fileName];
        if (!file) {
            this._files[fileName] = ts.createSourceFile(fileName, text, target);
            logger.debug("added " + fileName);
        }
        else if (file.text != text) {
            this._files[fileName] = ts.createSourceFile(fileName, text, target);
            this.invalidate(fileName);
            logger.debug("updated " + fileName);
        }
        return this._files[fileName];
    };
    CompilerHost.prototype.invalidate = function (fileName, seen) {
        var _this = this;
        seen = seen || [];
        if (seen.indexOf(fileName) < 0) {
            seen.push(fileName);
            var file = this._files[fileName];
            if (file) {
                file.checked = false;
                file.diags = [];
            }
            Object.keys(this._files)
                .map(function (key) { return _this._files[key]; })
                .forEach(function (file) {
                if (file.dependencies && file.dependencies.list.indexOf(fileName) >= 0) {
                    _this.invalidate(file.fileName, seen);
                }
            });
        }
    };
    CompilerHost.prototype.resolveModuleNames = function (moduleNames, containingFile) {
        var _this = this;
        return moduleNames.map(function (modName) {
            var dependencies = _this._files[containingFile].dependencies;
            if (dependencies) {
                var resolvedFileName = dependencies.mappings[modName];
                if (!resolvedFileName) {
                    if (_this._reportedFiles.indexOf(resolvedFileName) < 0) {
                        logger.warn(containingFile + ' -> ' + modName + ' could not be resolved');
                        _this._reportedFiles.push(resolvedFileName);
                    }
                    return undefined;
                }
                else {
                    var isExternalLibraryImport = isTypescriptDeclaration(resolvedFileName);
                    var extension = getExtension(resolvedFileName);
                    return { resolvedFileName: resolvedFileName, isExternalLibraryImport: isExternalLibraryImport, extension: extension };
                }
            }
            else {
                return undefined;
            }
        });
    };
    return CompilerHost;
}());
export { CompilerHost };
